-- -----------------------------------------------------------------------------------------------
-- PrefManRT script
-- Generated by sqlcat_db.py ( $Id: sqlcat_db2.pl 63227 2013-03-12 02:03:44Z jf185081 $ )
-- Generated 2019-08-19 11:58:45
-- Build Version: 7.3.1.138972
-- -----------------------------------------------------------------------------------------------
print CURRENT_TIMESTAMP;
print 'Beginning PrefManRT script on'
print @@VERSION;
print 'Using database ' + DB_NAME() + ' on ' + @@SERVERNAME;
print 'Running as user ' + SYSTEM_USER;

print 'Upgrading database ' + DB_NAME();
IF OBJECT_ID ( N'dbo.DBVersion', N'FN') IS NOT NULL
    print ' from DBVersion ' + [dbo].[DBVersion]();
print ' to 7.3.1.138972 (generated 2019-08-19 11:58:45)'

declare @dbn nvarchar(255)
set @dbn = db_name()

declare @error_msg_format nvarchar(512)
set @error_msg_format = CHAR(13) + CHAR(13) + 'THIS IS THE WRONG DATABASE (%s)' + CHAR(13) + CHAR(13)

IF db_name() = 'master'
BEGIN
    RAISERROR( @error_msg_format, 20, 1, @dbn ) WITH LOG, NOWAIT
END

IF OBJECT_ID ( N'dbo.LogixDBName', N'FN') IS NOT NULL
BEGIN
    IF [dbo].[LogixDBName]() <> 'PrefManRT'
    BEGIN
        RAISERROR( @error_msg_format, 20, 1, @dbn ) WITH LOG, NOWAIT
    END
END

IF NOT EXISTS (SELECT * FROM fn_my_permissions (db_name(), 'DATABASE') WHERE permission_name='ALTER')
BEGIN
    declare @error_permission nvarchar(256)
    set @error_permission = CHAR(13) + CHAR(13) + 'This user does not have sufficient permissions to run this script. It must be run by a member of the sysadmin fixed server role or a user with ALTER TRACE and ALTER DATABASE permissions.' + CHAR(13) + CHAR(13)
    RAISERROR( @error_permission, 18, 1 ) WITH NOWAIT
END

SET NOCOUNT ON;

--
-- -- DEFAULT CONSTRAINT renaming code --
-- Creates a stored proc to rename mis-named DEFAULT CONSTRAINTs, calls that stored proc, then DROPs that stored proc when it is no longer needed.
--
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Logix_FixDefaultConstraintNames]') AND type in (N'P', N'PC'))
BEGIN
    DROP PROCEDURE [dbo].[Logix_FixDefaultConstraintNames]
END
GO

CREATE PROCEDURE [dbo].[Logix_FixDefaultConstraintNames]
AS
BEGIN

    SET NOCOUNT ON
    declare @keepgoing as bit
    set @keepgoing = 1
    while ( @keepgoing = 1 )
    BEGIN
        set @keepgoing = 0

        DECLARE @cmd as nvarchar(512);
		    DECLARE @DFcmd as nvarchar(256);
		    DECLARE @DFObject as nvarchar(256);
        SELECT TOP 1 @DFObject = 'DF_' + OBJECT_NAME(dc.parent_object_id) + '_' + columnList.COLUMN_NAME, @cmd = 'dbo.sp_rename ' + dc.name + ', DF_' + OBJECT_NAME(dc.parent_object_id) + '_' + columnList.COLUMN_NAME + ', OBJECT ;'
                            FROM sys.default_constraints as dc
                            INNER JOIN INFORMATION_SCHEMA.COLUMNS AS columnList ON
                                columnList.TABLE_NAME = OBJECT_NAME(dc.parent_object_id) AND columnList.ORDINAL_POSITION = dc.parent_column_id
                        WHERE dc.is_system_named = 1
                            and SUBSTRING ( dc.name, 1, 4 ) = 'DF__'
                            and object_name(dc.parent_object_id) not like 'sys[^_]%'
                            and object_name(dc.parent_object_id) not like 'MS[a-z]%'
                            and objectproperty(dc.parent_object_id, 'IsUserTable') = 1
                            and objectproperty(dc.parent_object_id, 'IsMSShipped') = 0

        IF @@ROWCOUNT > 0
        BEGIN
            print 'Renaming incorrectly named DEFAULT CONSTRAINT ( ' + @cmd + ' )'
			      IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(@DFObject) AND type = 'D')
			      BEGIN
			        SET @DFcmd = 'ALTER TABLE [dbo].[CPE_Incentives] DROP CONSTRAINT ' +@DFObject;
			        EXEC( @DFcmd );
			      END
            EXEC( @cmd );
            set @keepgoing = 1
        END

    END -- while

END -- Logix_FixDefaultConstraintNames
GO

EXEC [dbo].[Logix_FixDefaultConstraintNames]
GO

DROP PROCEDURE [dbo].[Logix_FixDefaultConstraintNames]
GO

-- DEFAULT CONSTRAINT renaming complete


-- END SCRIPT HEADER ------------------------------------------------------


--
-- F:\ci-build\workspace\logix_7.3.1\Logix\tags\7.3.1/Source/sql_scripts/monitoring/tables/ --
--
print 'processing tables/DBA.PD_ActivityMonitor.sql'; 
--
GO
PRINT '---------------------------------------------------------------------------------------------------------------------------------'	
	PRINT 'Start of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)	

	--
	--	DBA Schema for PD
	--
	IF NOT EXISTS (SELECT * FROM sys.schemas WHERE name = N'DBA')
		EXEC sp_executesql N'CREATE SCHEMA [DBA] AUTHORIZATION [dbo]'
	GO

--	vii)	DBA.PD_ActivityMonitor

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects AS O WHERE O.name = N'PD_ActivityMonitor' AND O.type = 'U' AND O.SCHEMA_ID = SCHEMA_ID('DBA'))
		CREATE TABLE DBA.PD_ActivityMonitor(
			  ID 								INT 			 	NOT NULL		CONSTRAINT		PK_ActivityMonitor_ID						PRIMARY KEY			CLUSTERED		IDENTITY(1,1)
			, Created_On 						SMALLDATETIME 		NOT NULL 		CONSTRAINT		DF_ActivityMonitor_Created_On				DEFAULT								(CONVERT(SMALLDATETIME, GETDATE()))
			, Session_ID 						SMALLINT 			NOT NULL
			, User_Process 						CHAR(1) 			NULL
			, Login_Name						NVARCHAR(128) 		NOT NULL
			, Database_Name						NVARCHAR(128) 		NOT NULL
			, Task_State 						NVARCHAR(60) 		NOT NULL
			, Command 							NVARCHAR(50) 		NOT NULL
			, Application_Name					NVARCHAR(128) 		NOT NULL
			, Wait_Time_in_ms 					BIGINT 				NOT NULL
			, Wait_Type 						NVARCHAR(60) 		NOT NULL
			, Wait_Resource 					NVARCHAR(1024) 		NOT NULL
			, Blocked_By 						VARCHAR(30) 		NOT NULL
			, Head_Blocker 						VARCHAR(1) 			NOT NULL
			, Total_CPU_ms 						INT 				NOT NULL
			, Total_Physical_IO_in_MB			BIGINT 				NULL
			, Memory_USE_KB 					INT 				NULL
			, Open_Transactions 				INT 				NOT NULL
			, Login_Time 						DATETIME 			NOT NULL
			, Last_Request_Start_Time 			DATETIME 			NOT NULL
			, [Host_Name] 						NVARCHAR(128) 		NOT NULL
			, Net_Address						VARCHAR(48) 		NOT NULL
			, Execution_Context_ID 				INT 				NOT NULL
			, Request_ID 						INT 				NOT NULL
		) 
		ON [PRIMARY]
ELSE
	PRINT 'DBA.PD_ActivityMonitor is already added'
GO

--Changing column precision from 16 to 50
IF COLUMNPROPERTY( OBJECT_ID( '[DBA].[PD_ActivityMonitor]' ), 'Command', 'PRECISION' ) < 50 
	ALTER TABLE [DBA].[PD_ActivityMonitor] ALTER COLUMN [Command] [NVARCHAR](50) NOT NULL
GO


PRINT 'End of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)
PRINT '---------------------------------------------------------------------------------------------------------------------------------'	

print 'processing tables/DBA.PD_FKs_With_NoIndexes.sql'; 
--
GO
PRINT '---------------------------------------------------------------------------------------------------------------------------------'	
	PRINT 'Start of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)	

	--
	--	DBA Schema for PD
	--
	IF NOT EXISTS (SELECT * FROM sys.schemas WHERE name = N'DBA')
		EXEC sp_executesql N'CREATE SCHEMA [DBA] AUTHORIZATION [dbo]'
	GO

--	v)	DBA.PD_FKs_With_NoIndexes

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects AS O WHERE O.name = N'PD_FKs_With_NoIndexes' AND O.type = 'U' AND O.SCHEMA_ID = SCHEMA_ID('DBA'))
		CREATE TABLE DBA.PD_FKs_With_NoIndexes (
			  ID								INT					NOT NULL		CONSTRAINT		PK_PD_FKs_With_NoIndexes_ID					PRIMARY KEY			CLUSTERED		IDENTITY(1,1)
			, Created_On						SMALLDATETIME		NOT NULL		CONSTRAINT		DF_PD_FKs_With_NoIndexes_Created_On			DEFAULT								(CONVERT(SMALLDATETIME, GETDATE()))
			, Foreign_Key_Name					VARCHAR(100)
			, Relationship						VARCHAR(250)
			, Parent_Table_Index_State			VARCHAR(100)
			, Referenced_Table_Index_State		VARCHAR(100)
		) ON [PRIMARY]
	ELSE
		PRINT 'DBA.PD_FKs_With_NoIndexes is already added'
	GO
	

PRINT 'End of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)
	PRINT '---------------------------------------------------------------------------------------------------------------------------------'	

print 'processing tables/DBA.PD_IndexPhysicalStats.sql'; 
--
GO
PRINT '---------------------------------------------------------------------------------------------------------------------------------'	
	PRINT 'Start of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)	

	--
	--	DBA Schema for PD
	--
	IF NOT EXISTS (SELECT * FROM sys.schemas WHERE name = N'DBA')
		EXEC sp_executesql N'CREATE SCHEMA [DBA] AUTHORIZATION [dbo]'
	GO

--	vi)	DBA.PD_IndexPhysicalStats

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects AS O WHERE O.name = N'PD_IndexPhysicalStats' AND O.type = 'U' AND O.SCHEMA_ID = SCHEMA_ID('DBA'))
		CREATE TABLE DBA.PD_IndexPhysicalStats (
			  ID								INT					NOT NULL		CONSTRAINT		PK_PD_IndexPhysicalStats					PRIMARY KEY			CLUSTERED		IDENTITY(1,1)
			, Created_On						SMALLDATETIME		NOT NULL		CONSTRAINT		DF_PD_IndexPhysicalStats_Created_On			DEFAULT								(CONVERT(SMALLDATETIME, GETDATE()))
			, [Schema_Name]						VARCHAR(20)			NOT NULL
			, [Table_Name]						VARCHAR(100)		NOT NULL
			, [Index_Name]						VARCHAR(100)		NOT NULL
			, [Database_ID]						INT					NOT NULL
			, [Object_ID]						INT					NOT NULL
			, [Index_ID]						INT					NOT NULL
			, Partition_Number					INT					NULL
			, Index_Type_Desc					VARCHAR(30)			NULL
			, Alloc_Unit_Type_Desc				VARCHAR(30)			NULL
			, Index_Depth						INT					NULL
			, Index_Level						INT					NULL
			, Avg_fragmentation_in_percent		NUMERIC(10,2)		NULL
			, Fragment_count					INT					NULL
			, Avg_fragment_size_in_pages		NUMERIC(10,2)		NULL
			, Page_count						INT					NULL
			, Avg_page_space_used_in_percent	NUMERIC(10,2)		NULL
			, Created_By						VARCHAR(50)			NOT NULL		CONSTRAINT		DF_PD_IndexPhysicalStats_Created_By			DEFAULT								SYSTEM_USER
		)
		ON  [PRIMARY]
	ELSE
		PRINT 'DBA.PD_IndexPhysicalStats is already added'
	GO
	

PRINT 'End of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)
	PRINT '---------------------------------------------------------------------------------------------------------------------------------'	

print 'processing tables/DBA.PD_Index_Usage.sql'; 
--
GO
PRINT '---------------------------------------------------------------------------------------------------------------------------------'	
	PRINT 'Start of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)	

	--
	--	DBA Schema for PD
	--
	IF NOT EXISTS (SELECT * FROM sys.schemas WHERE name = N'DBA')
		EXEC sp_executesql N'CREATE SCHEMA [DBA] AUTHORIZATION [dbo]'
	GO

--	iv)	DBA.PD_Index_Usage

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects AS O WHERE O.name = N'PD_Index_Usage' AND O.type = 'U' AND O.SCHEMA_ID = SCHEMA_ID('DBA'))
		CREATE TABLE DBA.PD_Index_Usage(
			  ID								INT					NOT NULL		CONSTRAINT		PK_PD_Index_Usage_ID						PRIMARY KEY			CLUSTERED		IDENTITY(1,1)
			, Created_On						SMALLDATETIME		NOT NULL		CONSTRAINT		DF_PD_Index_Usage_Created_On				DEFAULT								(CONVERT(SMALLDATETIME, GETDATE()))
			, Category							VARCHAR(20)			NOT NULL
			, Table_Name						VARCHAR(50)			NOT NULL
			, Index_Name						VARCHAR(100)		NULL
			, User_Seeks						BIGINT				NULL
			, User_Scans						BIGINT				NULL
			, User_Lookups						BIGINT				NULL
			, User_Updates						BIGINT				NULL
			, Last_User_Scan					DATETIME			NULL
			, Last_User_Seek					DATETIME			NULL
		) ON [PRIMARY]
	ELSE
		PRINT 'DBA.PD_Index_Usage is already added'
	GO
	

PRINT 'End of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)
	PRINT '---------------------------------------------------------------------------------------------------------------------------------'	

print 'processing tables/DBA.PD_Missing_Indexes.sql'; 
--
GO
PRINT '---------------------------------------------------------------------------------------------------------------------------------'	
	PRINT 'Start of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)	

	--
	--	DBA Schema for PD
	--
	IF NOT EXISTS (SELECT * FROM sys.schemas WHERE name = N'DBA')
		EXEC sp_executesql N'CREATE SCHEMA [DBA] AUTHORIZATION [dbo]'
	GO

--	iii)	DBA.PD_Missing_Indexes

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects AS O WHERE O.name = N'PD_Missing_Indexes' AND O.type = 'U' AND O.SCHEMA_ID = SCHEMA_ID('DBA'))
		CREATE TABLE DBA.PD_Missing_Indexes(
			  ID								INT					NOT NULL		CONSTRAINT		PK_PD_Missing_Indexes_ID					PRIMARY KEY			CLUSTERED		IDENTITY(1,1)
			, Created_On						SMALLDATETIME		NOT NULL		CONSTRAINT		DF_PD_Missing_Indexes_Created_On			DEFAULT								(CONVERT(SMALLDATETIME, GETDATE()))
			, Category							VARCHAR(25)			NOT NULL
			, Total_Cost						BIGINT				NULL
			, Average_User_Impact				NUMERIC(5,2)		NULL
			, Table_Name						VARCHAR(50)			NULL
			, Equality_Usage					VARCHAR(500)		NULL		
			, InEquality_Usage					VARCHAR(500)		NULL
			, Include_Columns					VARCHAR(500)		NULL
			, Unique_Compiles					BIGINT				NULL
			, User_Scans						BIGINT				NULL
			, User_Seeks						BIGINT				NULL
		) ON [PRIMARY]
	ELSE
		PRINT 'DBA.PD_Missing_Indexes is already added'
	GO
	

PRINT 'End of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)
	PRINT '---------------------------------------------------------------------------------------------------------------------------------'	

print 'processing tables/DBA.PD_ServerHardware.sql'; 
--
GO
PRINT '---------------------------------------------------------------------------------------------------------------------------------'	
	PRINT 'Start of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)	

	--
	--	DBA Schema for PD
	--
	IF NOT EXISTS (SELECT * FROM sys.schemas WHERE name = N'DBA')
		EXEC sp_executesql N'CREATE SCHEMA [DBA] AUTHORIZATION [dbo]'
	GO

--	xi)		DBA.PD_ServerHardware

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects AS O WHERE O.name = N'PD_ServerHardware' AND O.type = 'U' AND O.SCHEMA_ID = SCHEMA_ID('DBA'))	
		CREATE TABLE DBA.PD_ServerHardware
		(
			  ID 								INT 			 	NOT NULL		CONSTRAINT		PK_PD_ServerHardware_ID						PRIMARY KEY			CLUSTERED		IDENTITY(1,1)
			, Created_On 						SMALLDATETIME 		NOT NULL 		CONSTRAINT		DF_PD_ServerHardware_Created_On				DEFAULT								(CONVERT(SMALLDATETIME, GETDATE()))
			, [Sql and OS Version]				VARCHAR(200)		NULL
			, [NoF Physical CPUs]				TINYINT				NULL
			, [NoF Logical CPUs]				TINYINT				NULL
			, [Physical Mem in GB]				NUMERIC(5,2)		NULL
			, [Available Physical Mem in GB]	NUMERIC(5,2)		NULL
			, [Total Page File Size in GB]		NUMERIC(5,2)		NULL
			, [System Memory State]				VARCHAR(20)			NULL
			, [Is it a VM]						VARCHAR(10)			NULL
			, [SqlServer Instance Start Time]	DATETIME			NULL
		) ON  [PRIMARY]
	ELSE
		PRINT 'DBA.PD_ServerHardware is already added'
	GO
	

PRINT 'End of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)
	PRINT '---------------------------------------------------------------------------------------------------------------------------------'	

print 'processing tables/DBA.PD_TableStats.sql'; 
--
GO
PRINT '---------------------------------------------------------------------------------------------------------------------------------'	
	PRINT 'Start of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)	

	--
	--	DBA Schema for PD
	--
	IF NOT EXISTS (SELECT * FROM sys.schemas WHERE name = N'DBA')
		EXEC sp_executesql N'CREATE SCHEMA [DBA] AUTHORIZATION [dbo]'
	GO

--	x)		DBA.PD_TableStats

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects AS O WHERE O.name = N'PD_TableStats' AND O.type = 'U' AND O.SCHEMA_ID = SCHEMA_ID('DBA'))	
		CREATE TABLE DBA.PD_TableStats
		(
			  ID 								INT 			 	NOT NULL		CONSTRAINT		PK_PD_TableStats_ID							PRIMARY KEY			CLUSTERED		IDENTITY(1,1)
			, Created_On 						SMALLDATETIME 		NOT NULL 		CONSTRAINT		DF_PD_TableStats_Created_On					DEFAULT								(CONVERT(SMALLDATETIME, GETDATE()))
			, Table_Name						VARCHAR(100)		NOT NULL
			, Index_Name						VARCHAR(100)			NULL
			, [Index_Type]						VARCHAR(70)			NOT	NULL
			, RowCounts							BIGINT				NOT NULL
			, TotalSpaceKB						INT					NOT	NULL
			, Is_Primary_Key					BIT					NOT NULL
		) ON [PRIMARY]
	ELSE
		PRINT 'DBA.PD_TableStats is already added'
	GO
	

PRINT 'End of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)
	PRINT '---------------------------------------------------------------------------------------------------------------------------------'	

print 'processing tables/DBA.PD_TopQueries.sql'; 
--
GO
PRINT '---------------------------------------------------------------------------------------------------------------------------------'	
	PRINT 'Start of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)	

	--
	--	DBA Schema for PD
	--
	IF NOT EXISTS (SELECT * FROM sys.schemas WHERE name = N'DBA')
		EXEC sp_executesql N'CREATE SCHEMA [DBA] AUTHORIZATION [dbo]'
	GO

--	ii)	DBA.PD_TopQueries

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects As O WHERE O.name = N'PD_TopQueries' AND O.type = 'U' AND O.SCHEMA_ID = SCHEMA_ID('DBA'))
		CREATE TABLE DBA.PD_TopQueries(
			  ID								INT					NOT NULL		CONSTRAINT		PK_PD_TopQueries_ID							PRIMARY KEY			CLUSTERED		IDENTITY(1,1)
			, Created_On						SMALLDATETIME		NOT NULL		CONSTRAINT		DF_PD_TopQueries_Created_On					DEFAULT								(CONVERT(SMALLDATETIME, GETDATE()))
			, [Top_Category]					VARCHAR(25)			NOT NULL
			, Query								VARCHAR(MAX)		NOT NULL
			, Execution_Count					BIGINT				NULL
			, Average_CPU_Used_in_S				INT					NULL
			, Total_Logical_Reads				BIGINT				NULL
			, Average_logical_reads				BIGINT				NULL
			, Last_Logical_Reads				INT					NULL
			, Total_Logical_Writes				BIGINT				NULL
			, Last_Logical_Writes				INT					NULL
			, Total_Worker_Time					BIGINT				NULL
			, Last_Worker_Time					BIGINT				NULL
			, Total_elapsed_time_in_S			INT					NULL
			, Last_elapsed_time_in_S			INT					NULL
			, Last_Execution_Time				INT					NULL
		) ON  [PRIMARY]
ELSE
        PRINT 'DBA.PD_TopQueries is already added'
GO

--Changing datatype from int to bigint
IF (SELECT system_type_id FROM sys.columns WHERE object_id = OBJECT_ID('[DBA].[PD_TopQueries]') AND name = 'Execution_Count') = 56 -- Integer
	ALTER TABLE [DBA].[PD_TopQueries] ALTER COLUMN [Execution_Count] BIGINT NULL
GO

--Changing datatype from int to bigint
IF (SELECT system_type_id FROM sys.columns WHERE object_id = OBJECT_ID('[DBA].[PD_TopQueries]') AND name = 'Total_Logical_Reads') = 56 -- Integer
	ALTER TABLE [DBA].[PD_TopQueries] ALTER COLUMN [Total_Logical_Reads] BIGINT NULL
GO

--Changing datatype from int to bigint
IF (SELECT system_type_id FROM sys.columns WHERE object_id = OBJECT_ID('[DBA].[PD_TopQueries]') AND name = 'Total_Logical_Writes') = 56 -- Integer
	ALTER TABLE [DBA].[PD_TopQueries] ALTER COLUMN [Total_Logical_Writes] BIGINT NULL
GO

PRINT 'End of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)
PRINT '---------------------------------------------------------------------------------------------------------------------------------'	

print 'processing tables/DBA.PD_UpdateStatistics.sql'; 
--
GO
PRINT '---------------------------------------------------------------------------------------------------------------------------------'	
	PRINT 'Start of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)	

	--
	--	DBA Schema for PD
	--
	IF NOT EXISTS (SELECT * FROM sys.schemas WHERE name = N'DBA')
		EXEC sp_executesql N'CREATE SCHEMA [DBA] AUTHORIZATION [dbo]'
	GO

--	ix)		DBA.PD_UpdateStatistics

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects AS O WHERE O.name = N'PD_UpdateStatistics' AND O.type = 'U' AND O.SCHEMA_ID = SCHEMA_ID('DBA'))	
		CREATE TABLE DBA.PD_UpdateStatistics
		(
			  ID 								INT 			 	NOT NULL		CONSTRAINT		PK_PD_UpdateStatistics_ID					PRIMARY KEY			CLUSTERED		IDENTITY(1,1)
			, Created_On 						SMALLDATETIME 		NOT NULL 		CONSTRAINT		DF_PD_UpdateStatistics_Created_On			DEFAULT								(CONVERT(SMALLDATETIME, GETDATE()))
			, Table_Name						VARCHAR(100)		NOT NULL
			, Statistic							VARCHAR(100)		NOT NULL
			, [Statistic Type]					VARCHAR(100)		NOT	NULL
			, [Stats Last Updated]				DATETIME				NULL
			, ModifiedRows						BIGINT					NULL
			, No_Recompute						BIT					NOT NULL
		) ON [PRIMARY]
	ELSE
		PRINT 'DBA.PD_UpdateStatistics is already added'
	GO
	

PRINT 'End of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)
	PRINT '---------------------------------------------------------------------------------------------------------------------------------'	

print 'processing tables/DBA.PD_WaitStats.sql'; 
--
GO
PRINT '---------------------------------------------------------------------------------------------------------------------------------'	
	PRINT 'Start of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)	

	--
	--	DBA Schema for PD
	--
	IF NOT EXISTS (SELECT * FROM sys.schemas WHERE name = N'DBA')
		EXEC sp_executesql N'CREATE SCHEMA [DBA] AUTHORIZATION [dbo]'
	GO

--	i)	DBA.PD_WaitStats

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects AS O WHERE O.name = N'PD_WaitStats' AND O.type = 'U' AND O.SCHEMA_ID = SCHEMA_ID('DBA'))
		CREATE TABLE DBA.PD_WaitStats(
			  ID								INT					NOT NULL		CONSTRAINT		PK_PD_WaitStats_ID							PRIMARY KEY			CLUSTERED		IDENTITY(1,1)
			, Created_On						SMALLDATETIME		NOT NULL		CONSTRAINT		DF_PD_WaitStats_Created_On					DEFAULT								(CONVERT(SMALLDATETIME, GETDATE()))
			, WaitType							NVARCHAR(60)		NOT NULL	
			, Wait_S							DECIMAL(14,2)		NULL
			, Resource_S						DECIMAL(14,2)		NULL
			, Signal_S							DECIMAL(14,2)		NULL
			, WaitCount							BIGINT				NOT NULL
			, Percentage						DECIMAL(4,2)		NULL
			, AvgWait_S							DECIMAL(14,4)		NULL
			, AvgRes_S							DECIMAL(14,4)		NULL
			, AvgSig_S							DECIMAL(14,4)		NULL
		) ON [PRIMARY]
	ELSE
		PRINT 'DBA.PD_WaitStats is already added'
	GO
	
	
PRINT 'End of adding schema and table for ' + DB_NAME() + ' database for AMS_PD' + CONVERT(VARCHAR, GETDATE(), 109)
	PRINT '---------------------------------------------------------------------------------------------------------------------------------'		


--
-- F:\ci-build\workspace\logix_7.3.1\Logix\tags\7.3.1/Source/sql_scripts/monitoring/views/ --
--

--
-- F:\ci-build\workspace\logix_7.3.1\Logix\tags\7.3.1/Source/sql_scripts/monitoring/functions/ --
--

--
-- F:\ci-build\workspace\logix_7.3.1\Logix\tags\7.3.1/Source/sql_scripts/monitoring/storedprocedures/ --
--
print 'processing storedprocedures/PD_Job.sql'; 
--
GO
-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
--
--		Purpose		:	Create AMS_PD job
--		Author		:	Uday K. Sangepu for NCR on December 5, 2012 
--
-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

--
--	Start of script:	PD_Job.sql
--

SET NOCOUNT ON

BEGIN TRY

	BEGIN TRANSACTION Add_AMS_PD_Job

		-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
		--	I)	Create Job: AMS_PD
		-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
		
		DECLARE @JobID		UNIQUEIDENTIFIER
				, @ERR 		INT
				, @DBNAME	SYSNAME
				, @JOBNAME  SYSNAME

		-- Get the actual database name into a variable of SYSNAME datatype
		SELECT @DBNAME = DB_NAME() 
		SELECT @JOBNAME = N'AMS_PD_' + @DBNAME
		--print 'JOBNAME: ' + @JOBNAME
		
		--Get jobstep name to verify if it is exists for each jobstep
        DECLARE @StepName Varchar(50)
        Select @StepName = step_name from msdb.dbo.sysjobsteps where job_id = @JobID and database_name = @DBNAME  		

		
		--	EXECUTE msdb.dbo.sp_delete_job @job_name = N'AMS_PD'
		If not exists(select * from msdb.dbo.sysjobs WHERE job_id = @jobId and name  = @JOBNAME)	
	Begin
		EXECUTE msdb.dbo.sp_add_job 
				  @job_name					=	@JOBNAME
				, @enabled					=	1
				, @description				=	N'Monitor and Gather performance diagnostic metrics for the database server'
				, @owner_login_name			=	N'sa'
				, @notify_level_eventlog	=	2
				, @job_id					=	@JobID OUTPUT

		SELECT @ERR = @@ERROR
		
		IF (@ERR <> 0) 
		BEGIN 
			PRINT 'msdb.dbo.sp_add_job failed for AMS_PD'
			ROLLBACK TRANSACTION Add_AMS_PD_Job
			RETURN
		END

		SELECT @JobID [AMS_PD JobID]
	End	

		
		-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
		--	II)	Create Job steps
		-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

		--
		--	Step 1: Start AMS_PD Job
		--
		If not exists(select * from msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_name =@StepName and database_name = @DBNAME)	
	 Begin
		EXECUTE msdb.dbo.sp_add_jobstep
				  @job_id					=	@JobID
				, @step_id					=	1
				, @step_name				=	N'Start AMS_PD Job' 
				, @subsystem				=	'TSQL'
				, @on_success_action		=	3
				, @on_success_step_id		=	0
				, @on_fail_action			=	3
				, @on_fail_step_id			=	0
				, @database_name			=	@DBNAME
				, @flags					=	6
				, @command					=	N'
													-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
													--
													--	Purpose	:	Start AMS_PD Job
													--	Author	:	Uday K. Sangepu for AMS (NCR) on December 13, 2012
													--
													-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

													DECLARE   @JobStartTime	DATETIME = GETDATE()
													PRINT ''Performance Diagnostics Job Start: '' + CONVERT(VARCHAR, @JobStartTime, 109)		--	With Milli Seconds
													PRINT ''------------------------------------------------------------------------------------------------------''
												'

		SELECT @ERR = @@ERROR
		
		IF (@ERR <> 0) 
		BEGIN 
			PRINT 'msdb.dbo.sp_add_jobstep failed for Step 1: Start AMS_PD Job'
			ROLLBACK TRANSACTION Add_AMS_PD_Job
			RETURN
		END
    End
		--
		--	Step 2: WaitStats
		--
       If not exists(select * from msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_name =@StepName and database_name = @DBNAME)
     Begin
		EXECUTE msdb.dbo.sp_add_jobstep
				  @job_id					=	@JobID
				, @step_id					=	2
				, @step_name				=	N'WaitStats'
				, @subsystem				=	'TSQL'
				, @on_success_action		=	3
				, @on_success_step_id		=	0
				, @on_fail_action			=	3
				, @on_fail_step_id			=	0
				, @database_name			=	@DBNAME
				, @flags					=	6
				, @command					=	N'
													-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
													--
													--	Purpose	:	Gather Wait Stats 
													--	Author	:	Uday K. Sangepu for AMS (NCR) on December 13, 2012
													--
													-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

													;WITH	Waits 
													AS
													(
														SELECT wait_type										AS [Wait_Type]
															, wait_time_ms / 1000.0 							AS WaitS
															, (wait_time_ms - signal_wait_time_ms) / 1000.0 	AS ResourceS
															, signal_wait_time_ms / 1000.0 						AS SignalS
															, waiting_tasks_count 								AS WaitCount
															, 100.0 * wait_time_ms / SUM(wait_time_ms) OVER () 	AS Percentage
															, ROW_NUMBER() OVER ( ORDER BY wait_time_ms DESC) 	AS [RowNum]
														FROM   sys.dm_os_wait_stats
														WHERE  wait_type NOT IN (	''CLR_SEMAPHORE'',				''LAZYWRITER_SLEEP'',				''RESOURCE_QUEUE'',						''SLEEP_TASK'',				''SLEEP_SYSTEMTASK''
																					, ''SQLTRACE_BUFFER_FLUSH'',		''WAITFOR'',						''LOGMGR_QUEUE'',							''CHECKPOINT_QUEUE'',			''REQUEST_FOR_DEADLOCK_SEARCH''
																					, ''XE_TIMER_EVENT'',				''BROKER_TO_FLUSH'',				''BROKER_TASK_STOP'',						''CLR_MANUAL_EVENT'',			''CLR_AUTO_EVENT''
																					, ''DISPATCHER_QUEUE_SEMAPHORE'', ''FT_IFTS_SCHEDULER_IDLE_WAIT'',	''XE_DISPATCHER_WAIT'',					''XE_DISPATCHER_JOIN'',		''BROKER_EVENTHANDLER''
																					, ''TRACEWRITE'',					''FT_IFTSHC_MUTEX'',				''SQLTRACE_INCREMENTAL_FLUSH_SLEEP'',		''BROKER_RECEIVE_WAITFOR'',	''ONDEMAND_TASK_QUEUE''
																					, ''DBMIRROR_EVENTS_QUEUE'',		''DBMIRRORING_CMD'',				''BROKER_TRANSMITTER'',					''SQLTRACE_WAIT_ENTRIES'',	''SLEEP_BPOOL_FLUSH''
																					, ''SQLTRACE_LOCK''
																				)	--	These are filtered out as these are usually benign
													)
													INSERT INTO DBA.PD_WaitStats(WaitType, Wait_S, Resource_S, Signal_S, WaitCount, Percentage, AvgWait_S, AvgRes_S, AvgSig_S)
													SELECT    TOP 10
															  W1.wait_type 												AS WaitType
															, CAST (W1.WaitS AS DECIMAL (14, 2)) 						AS Wait_S
															, CAST (W1.ResourceS AS DECIMAL (14, 2)) 					AS Resource_S
															, CAST (W1.SignalS AS DECIMAL (14, 2)) 						AS Signal_S
															, W1.WaitCount 												AS WaitCount
															, CAST (W1.Percentage AS DECIMAL (4, 2)) 					AS Percentage
															, CAST ((W1.WaitS / W1.WaitCount) AS DECIMAL (14, 4)) 		AS AvgWait_S
															, CAST ((W1.ResourceS / W1.WaitCount) AS DECIMAL (14, 4)) 	AS AvgRes_S
															, CAST ((W1.SignalS / W1.WaitCount) AS DECIMAL (14, 4)) 	AS AvgSig_S
													FROM Waits AS W1
													INNER JOIN Waits AS W2
														ON W2.RowNum <= W1.RowNum
													GROUP BY  W1.RowNum
															, W1.wait_type
															, W1.WaitS
															, W1.ResourceS
															, W1.SignalS
															, W1.WaitCount
															, W1.Percentage
													HAVING   SUM(W2.Percentage) - W1.Percentage < 95; -- percentage threshold
												'

		SELECT @ERR = @@ERROR
		
		IF (@ERR <> 0) 
		BEGIN 
			PRINT 'msdb.dbo.sp_add_jobstep failed for Step 2: WaitStats'
			ROLLBACK TRANSACTION Add_AMS_PD_Job
			RETURN
		END
	End										

		--
		--	Step 3: Top_N_Queries
		--
        If not exists(select * from msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_name =@StepName and database_name = @DBNAME)
     Begin
		EXECUTE msdb.dbo.sp_add_jobstep
				  @job_id					=	@JobID
				, @step_id					=	3
				, @step_name				=	N'Top_N_Queries'
				, @subsystem				=	'TSQL'
				, @on_success_action		=	3
				, @on_success_step_id		=	0
				, @on_fail_action			=	3
				, @on_fail_step_id			=	0
				, @database_name			=	@DBNAME
				, @flags					=	6
				, @command					=	N'
													-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
													--
													--	Purpose	:	Gather queries that take the most resources
													--				i)		Total CPU usage
													--				ii)		Average CPU usage
													--				iii)	Total Logial IO
													--				iv)		Average Logical IO
													--
													--	Author	:	Uday K. Sangepu for AMS (NCR) on December 13, 2012
													--
													-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

													--
													--	i)	Total CPU usage	
													--
													INSERT INTO DBA.PD_TopQueries (Top_Category, Query, Execution_Count, Average_CPU_Used_in_S, Total_Logical_Reads, Average_logical_reads, Last_Logical_Reads, Total_Logical_Writes, Last_Logical_Writes, Total_Worker_Time, Last_Worker_Time, Total_elapsed_time_in_S, Last_elapsed_time_in_S, Last_Execution_Time)
													SELECT    TOP 10 
															  ''Top Total CPU Time''																	AS	[Top_Category]
															, SUBSTRING(qt.TEXT, (qs.statement_start_offset / 2) + 1, 
																				((CASE qs.statement_end_offset 
																						WHEN -1 THEN DATALENGTH(qt.TEXT) 
																						ELSE qs.statement_end_offset 
																					END - qs.statement_start_offset) / 2) + 1
																		)																			AS	[Query]
															, qs.execution_count																	AS	[Execution_Count]
															, CAST((qs.total_worker_time * 1.0) / (qs.execution_count * 1000000) AS NUMERIC(10,2))	AS	[Average_CPU_Used_in_S]
															, qs.total_logical_reads																AS	[Total_Logical_Reads]
															, CONVERT(BIGINT, total_logical_reads/execution_count)									AS	[Average_logical_reads]
															, qs.last_logical_reads																	AS	[Last_Logical_Reads]
															, qs.total_logical_writes																AS	[Total_Logical_Writes]
															, qs.last_logical_writes																AS	[Last_Logical_Writes]
															, CONVERT(BIGINT, qs.total_worker_time)													AS	[Total_Worker_Time]
															, CONVERT(BIGINT, qs.last_worker_time)													AS	[Last_Worker_Time]
															, CONVERT(INT, qs.total_elapsed_time / 1000000)											AS	[total_elapsed_time_in_S]
															, CONVERT(INT, qs.last_elapsed_time / 1000000)											AS	[last_elapsed_time_in_S]
															, CONVERT(INT, qs.last_execution_time)													AS	[Last_Execution_Time]
													--		, qp.query_plan																			AS	[Query_Plan]
													FROM sys.dm_exec_query_stats AS qs 
													CROSS APPLY sys.dm_exec_sql_text (qs.sql_handle) AS qt 
													CROSS APPLY sys.dm_exec_query_plan (qs.plan_handle) AS qp
													ORDER BY qs.total_worker_time DESC; 


													--
													--	ii)	Top Average CPU Time
													--
													INSERT INTO DBA.PD_TopQueries (Top_Category, Query, Execution_Count, Average_CPU_Used_in_S, Total_Logical_Reads, Average_logical_reads, Last_Logical_Reads, Total_Logical_Writes, Last_Logical_Writes, Total_Worker_Time, Last_Worker_Time, Total_elapsed_time_in_S, Last_elapsed_time_in_S, Last_Execution_Time)
													SELECT    TOP 10 
															  ''Top Average CPU Time''																AS	[Top_Category]
															, SUBSTRING(qt.TEXT, (qs.statement_start_offset / 2) + 1, 
																				((CASE qs.statement_end_offset 
																						WHEN -1 THEN DATALENGTH(qt.TEXT) 
																						ELSE qs.statement_end_offset 
																					END - qs.statement_start_offset) / 2) + 1
																		)																			AS	[Query]
															, qs.execution_count																	AS	[Execution_Count]
															, CAST((qs.total_worker_time * 1.0) / (qs.execution_count * 1000000) AS NUMERIC(10,2))	AS	[Average_CPU_Used_in_S]
															, qs.total_logical_reads																AS	[Total_Logical_Reads]
															, CONVERT(BIGINT, total_logical_reads/execution_count)									AS	[Average_logical_reads]
															, qs.last_logical_reads																	AS	[Last_Logical_Reads]
															, qs.total_logical_writes																AS	[Total_Logical_Writes]
															, qs.last_logical_writes																AS	[Last_Logical_Writes]
															, CONVERT(BIGINT, qs.total_worker_time)													AS	[Total_Worker_Time]
															, CONVERT(BIGINT, qs.last_worker_time)													AS	[Last_Worker_Time]
															, CONVERT(INT, qs.total_elapsed_time / 1000000)											AS	[total_elapsed_time_in_S]
															, CONVERT(INT, qs.last_elapsed_time / 1000000)											AS	[last_elapsed_time_in_S]
															, CONVERT(INT, qs.last_execution_time)													AS	[Last_Execution_Time]
													--		, qp.query_plan																			AS	[Query_Plan]
													FROM sys.dm_exec_query_stats AS qs 
													CROSS APPLY sys.dm_exec_sql_text (qs.sql_handle) AS qt 
													CROSS APPLY sys.dm_exec_query_plan (qs.plan_handle) AS qp
													ORDER BY [Average_CPU_Used_in_S] DESC; -- CPU time

													--
													--	iii)	Total Logical IO
													--
													INSERT INTO DBA.PD_TopQueries (Top_Category, Query, Execution_Count, Average_CPU_Used_in_S, Total_Logical_Reads, Average_logical_reads, Last_Logical_Reads, Total_Logical_Writes, Last_Logical_Writes, Total_Worker_Time, Last_Worker_Time, Total_elapsed_time_in_S, Last_elapsed_time_in_S, Last_Execution_Time)
													SELECT	TOP 10 
															''Top Total Logical IO''																	AS	[Top_Category]
															, SUBSTRING(qt.TEXT, (qs.statement_start_offset / 2) + 1, 
																				((CASE qs.statement_end_offset 
																						WHEN -1 THEN DATALENGTH(qt.TEXT) 
																						ELSE qs.statement_end_offset 
																					END - qs.statement_start_offset) / 2) + 1
																		)																			AS	[Query]
															, qs.execution_count																	AS	[Execution_Count]
															, CAST((qs.total_worker_time * 1.0) / (qs.execution_count * 1000000) AS NUMERIC(10,2))	AS	[Average_CPU_Used_in_S]
															, qs.total_logical_reads																AS	[Total_Logical_Reads]
															, CONVERT(BIGINT, total_logical_reads/execution_count)									AS	[Average_logical_reads]
															, qs.last_logical_reads																	AS	[Last_Logical_Reads]
															, qs.total_logical_writes																AS	[Total_Logical_Writes]
															, qs.last_logical_writes																AS	[Last_Logical_Writes]
															, CONVERT(BIGINT, qs.total_worker_time)													AS	[Total_Worker_Time]
															, CONVERT(BIGINT, qs.last_worker_time)													AS	[Last_Worker_Time]
															, CONVERT(INT, qs.total_elapsed_time / 1000000)											AS	[total_elapsed_time_in_S]
															, CONVERT(INT, qs.last_elapsed_time / 1000000)											AS	[last_elapsed_time_in_S]
															, CONVERT(INT, qs.last_execution_time)													AS	[Last_Execution_Time]
													FROM sys.dm_exec_query_stats AS qs 
													CROSS APPLY sys.dm_exec_sql_text (qs.sql_handle) AS qt 
													CROSS APPLY sys.dm_exec_query_plan (qs.plan_handle) AS qp
													ORDER BY [Total_Logical_Reads] DESC; 


													--
													--	iv)	Average Logical IO
													--
													INSERT INTO DBA.PD_TopQueries 	(Top_Category, Query, Execution_Count, Average_CPU_Used_in_S, Total_Logical_Reads, Average_logical_reads, Last_Logical_Reads, Total_Logical_Writes, Last_Logical_Writes, Total_Worker_Time, Last_Worker_Time, Total_elapsed_time_in_S, Last_elapsed_time_in_S, Last_Execution_Time)
													SELECT	TOP 10 
															''Top Average Logical IO''																AS	[Top_Category]
															, SUBSTRING(qt.TEXT, (qs.statement_start_offset / 2) + 1, 
																				((CASE qs.statement_end_offset 
																						WHEN -1 THEN DATALENGTH(qt.TEXT) 
																						ELSE qs.statement_end_offset 
																					END - qs.statement_start_offset) / 2) + 1
																		)																			AS	[Query]
															, qs.execution_count																	AS	[Execution_Count]
															, CAST((qs.total_worker_time * 1.0) / (qs.execution_count * 1000000) AS NUMERIC(10,2))	AS	[Average_CPU_Used_in_S]
															, qs.total_logical_reads																AS	[Total_Logical_Reads]
															, CONVERT(BIGINT, total_logical_reads/execution_count)									AS	[Average_logical_reads]
															, qs.last_logical_reads																	AS	[Last_Logical_Reads]
															, qs.total_logical_writes																AS	[Total_Logical_Writes]
															, qs.last_logical_writes																AS	[Last_Logical_Writes]
															, CONVERT(BIGINT, qs.total_worker_time)													AS	[Total_Worker_Time]
															, CONVERT(BIGINT, qs.last_worker_time)													AS	[Last_Worker_Time]
															, CONVERT(INT, qs.total_elapsed_time / 1000000)											AS	[total_elapsed_time_in_S]
															, CONVERT(INT, qs.last_elapsed_time / 1000000)											AS	[last_elapsed_time_in_S]
															, CONVERT(INT, qs.last_execution_time)													AS	[Last_Execution_Time]
													FROM sys.dm_exec_query_stats AS qs 
													CROSS APPLY sys.dm_exec_sql_text (qs.sql_handle) AS qt 
													CROSS APPLY sys.dm_exec_query_plan (qs.plan_handle) AS qp
													ORDER BY [Average_logical_reads] DESC; 
												'

		SELECT @ERR = @@ERROR
		
		IF (@ERR <> 0) 
		BEGIN 
			PRINT 'msdb.dbo.sp_add_jobstep failed for Step 3: Top_N_Queries'
			ROLLBACK TRANSACTION Add_AMS_PD_Job
			RETURN
		END
     End
												
		--
		--	Step 4: Index Stats
		--
        If not exists(select * from msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_name =@StepName and database_name = @DBNAME)
     Begin
		EXECUTE msdb.dbo.sp_add_jobstep
				  @job_id					=	@JobID
				, @step_id					=	4
				, @step_name				=	N'Index_Stats'
				, @subsystem				=	'TSQL'
				, @on_success_action		=	3
				, @on_success_step_id		=	0
				, @on_fail_action			=	3
				, @on_fail_step_id			=	0
				, @database_name			=	@DBNAME
				, @flags					=	6
				, @command					=	N'
													-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
													--
													--	Purpose	:	Gather necessary stats on indexes 
													--					i)		Missing Indexes
													--					ii)		Index UsageUsage
													--					iii)	Do All FK have indexes on them (from Dave Levy) 
													--					iv)		Index Stats (internal & external fragmentation, allocation_unit_type, etc)

													--	Author	:	Uday K. Sangepu for AMS (NCR) on December 13, 2012
													--
													-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


													--
													--	i)	Missing Indexes
													--
														INSERT INTO DBA.PD_Missing_Indexes(Category, Total_Cost, Average_User_Impact, Table_Name, Equality_Usage, InEquality_Usage, Include_Columns, Unique_Compiles, User_Scans, User_Seeks)
														SELECT  TOP 25
																  ''Missing Indexes''		AS [Category]
																, ROUND(avg_total_user_cost * avg_user_impact * (user_seeks + user_scans),0) AS [Total Cost]
																, avg_user_impact		AS [Average_User_Impact]
																, statement				AS [Table_Name]
																, equality_columns		AS [Equality_Usage]
																, inequality_columns	AS [Inequality_Usage]
																, included_columns		AS [Include_Cloumns]
																, s.unique_compiles		AS [Unique_Compiles]
																, s.user_scans			AS [User_Scans]
																, s.user_seeks			AS [User_Seeks]
														FROM sys.dm_db_missing_index_groups g 
														INNER JOIN sys.dm_db_missing_index_group_stats s 
															ON s.group_handle = g.index_group_handle 
														INNER JOIN sys.dm_db_missing_index_details d 
															ON d.index_handle = g.index_handle
														ORDER BY [Total Cost] DESC;

													--
													--	ii)	Index Usage
													--

														INSERT INTO DBA.PD_Index_Usage(Category, Table_Name, Index_Name, User_Seeks, User_Scans, User_Lookups, User_Updates, Last_User_Scan, Last_User_Seek)
														SELECT     ''Index Usage''
																, OBJECT_NAME(S.[OBJECT_ID])
																, I.[NAME]
																, USER_SEEKS
																, USER_SCANS
																, USER_LOOKUPS
																, USER_UPDATES
																, last_user_scan
																, last_system_seek
														FROM SYS.DM_DB_INDEX_USAGE_STATS AS S
														INNER JOIN SYS.INDEXES AS I
															ON I.[OBJECT_ID] = S.[OBJECT_ID]
															AND I.INDEX_ID = S.INDEX_ID
														WHERE   OBJECTPROPERTY(S.[OBJECT_ID],''IsUserTable'') = 1 
														AND S.database_id = DB_ID()
														And OBJECT_NAME(S.[OBJECT_ID]) not like ''%PD_%''


													--
													--	iii)	Do All FK have indexes on them (from Dave Levy) 
													--	

														INSERT INTO DBA.PD_FKs_With_NoIndexes (Foreign_Key_Name, Relationship, Parent_Table_Index_State, Referenced_Table_Index_State)
														SELECT		OBJECT_NAME(fk.object_id) AS [foreign_key_name],
																	QUOTENAME(SCHEMA_NAME(pt.schema_id)) + ''.'' + QUOTENAME(OBJECT_NAME(fk.parent_object_id)) + '' -> '' + QUOTENAME(SCHEMA_NAME(rt.schema_id)) + ''.'' + QUOTENAME(OBJECT_NAME(fk.referenced_object_id)) AS [relationship],
																	CASE 
																			WHEN COUNT(pic.column_id) < COUNT(DISTINCT fkc.constraint_column_id) 
																				THEN ''No Covering Index on '' + QUOTENAME(SCHEMA_NAME(pt.schema_id)) + ''.'' + QUOTENAME(OBJECT_NAME(fk.parent_object_id)) 
																			ELSE ''Covered'' 
																	END AS parent_table_index_state,
																	CASE	
																			WHEN COUNT(ric.column_id) < COUNT(DISTINCT fkc.constraint_column_id) 
																				THEN ''No Covering Index on '' + QUOTENAME(SCHEMA_NAME(rt.schema_id)) + ''.'' + QUOTENAME(OBJECT_NAME(fk.referenced_object_id)) 
																			ELSE ''Covered'' 
																	END AS referenced_table_index_state
														FROM		sys.foreign_keys fk
														INNER JOIN sys.foreign_key_columns fkc
															ON fk.object_id = fkc.constraint_object_id
														INNER JOIN sys.tables pt
															ON fkc.parent_object_id = pt.object_id
														INNER JOIN sys.tables rt
															ON fkc.referenced_object_id = rt.object_id
														LEFT OUTER JOIN sys.indexes pix
															ON fkc.parent_object_id = pix.object_id
															AND pix.is_disabled = 0
															AND pix.is_hypothetical = 0
														LEFT OUTER JOIN sys.index_columns pic
															ON fkc.parent_column_id = pic.column_id
															AND pix.object_id = pic.object_id
															AND pix.index_id = pic.index_id
															AND pic.index_column_id = fkc.constraint_column_id
														LEFT OUTER JOIN sys.indexes rix
															ON fkc.referenced_object_id = rix.object_id
															AND rix.is_disabled = 0
															AND rix.is_hypothetical = 0
														LEFT OUTER JOIN sys.index_columns ric
															ON fkc.referenced_column_id = ric.column_id
															AND rix.object_id = ric.object_id
															AND rix.index_id = ric.index_id
															AND ric.index_column_id = fkc.constraint_column_id
														GROUP BY	fk.object_id,
																	fk.parent_object_id,
																	pt.schema_id,
																	fk.referenced_object_id,
																	rt.schema_id


													--
													--	iv)		Index Stats (internal & external fragmentation, allocation_unit_type, etc)
													--

														--
														--	Metrics to Measure the progress
														--
														--	Variables
														DECLARE   @IndexStats_Sql 	NVARCHAR(MAX) =	''''
																, @SqlLength		INT

														--	Generate SQL statement to run sys.dm_db_index_physical_stats query on all the indexes			
														SELECT @IndexStats_Sql  = @IndexStats_Sql + ''SELECT '''''' + schema_name(O.schema_id) + '''''' AS [Schema_Name], '''''' + OBJECT_NAME(O.object_id) + '''''' AS [Table_Name], '''''' + I.name + '''''' AS [Index_Name], database_id, object_id, index_id, partition_number, index_type_desc, alloc_unit_type_desc, index_depth, index_level, CONVERT(NUMERIC(10,2), avg_fragmentation_in_percent), fragment_count, CONVERT(NUMERIC(10,2), avg_fragment_size_in_pages), page_count, CONVERT(NUMERIC(10,2), avg_page_space_used_in_percent) FROM sys.dm_db_index_physical_stats('' + CONVERT(VARCHAR, DB_ID()) + '', '' + CONVERT(VARCHAR, O.object_id) + '','' + CONVERT(VARCHAR, I.index_id) + '', NULL, DEFAULT) UNION ALL ''
														FROM sys.indexes AS I
														INNER JOIN sys.objects AS O 
															ON O.object_id = I.object_id
														WHERE I.index_id > 0
														ORDER BY OBJECT_NAME(O.object_id)

														--	Remove ''UNION ALL'' at the end
														SELECT @SqlLength = LEN(@IndexStats_Sql)
														SELECT @IndexStats_Sql = SUBSTRING(@IndexStats_Sql, 1, @SqlLength-9)
														
														--	INSERT  result set into DBADB table
														INSERT INTO DBA.PD_IndexPhysicalStats ([Schema_Name], [Table_Name], [Index_Name], [Database_ID], [Object_ID], [Index_ID], Partition_Number, Index_Type_Desc, Alloc_Unit_Type_Desc, Index_Depth, Index_Level, Avg_fragmentation_in_percent, Fragment_count, Avg_fragment_size_in_pages, Page_count, Avg_page_space_used_in_percent) 
														EXEC sp_ExecuteSql @stmt = @IndexStats_Sql 
												'


		SELECT @ERR = @@ERROR
		
		IF (@ERR <> 0) 
		BEGIN 
			PRINT 'msdb.dbo.sp_add_jobstep failed for Step 4: Index Stats'
			ROLLBACK TRANSACTION Add_AMS_PD_Job
			RETURN
		END
	End											
		--
		--	Step 5: Activity Monitor
		--
		If not exists(select * from msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_name =@StepName and database_name = @DBNAME)
     Begin
		EXECUTE msdb.dbo.sp_add_jobstep
				  @job_id					=	@JobID
				, @step_id					=	5
				, @step_name				=	N'Activity_Monitor'
				, @subsystem				=	'TSQL'
				, @on_success_action		=	3
				, @on_success_step_id		=	0
				, @on_fail_action			=	3
				, @on_fail_step_id			=	0
				, @database_name			=	@DBNAME
				, @flags					=	6
				, @command					=	N'

													-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
													--
													--	Purpose	:	Take a snapshot of Activity Monitor 
													--	Author	:	Uday K. Sangepu for AMS (NCR) on December 13, 2012
													--
													-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

													INSERT INTO DBA.PD_ActivityMonitor
													(		 
														  Session_ID 				
														, User_Process 				
														, Login_Name				
														, Database_Name				
														, Task_State 				
														, Command 					
														, Application_Name				
														, Wait_Time_in_ms 			
														, Wait_Type 				
														, Wait_Resource 			
														, Blocked_By 				
														, Head_Blocker 				
														, Total_CPU_ms 				
														, Total_Physical_IO_in_MB	
														, Memory_USE_KB 			
														, Open_Transactions 		
														, Login_Time 				
														, Last_Request_Start_Time 	
														, Host_Name 				
														, Net_Address					
														, Execution_Context_ID 			
														, Request_ID 					
													)
													SELECT 
														  Session_ID 				=	s.session_id
														, User_Process 				=	CONVERT(CHAR(1), s.is_user_process)
														, Login_Name				=	s.login_name
														, Database_Name				=	ISNULL(DB_NAME(p.dbid), N'''')
														, Task_State 				=	ISNULL(t.task_state, N'''')
														, Command 					=	ISNULL(r.command, N'''')
														, Application_Name 			=	ISNULL(s.program_name, N'''')
														, Wait_Time_in_ms 			=	ISNULL(w.wait_duration_ms, 0)
														, Wait_Type 				=	ISNULL(w.wait_type, N'''')
														, Wait_Resource 			=	ISNULL(w.resource_description, N'''')
														, Blocked_By 				=	ISNULL(CONVERT (VARCHAR, w.blocking_session_id), '''')
														, Head_Blocker 				=	CASE
																							-- session has an active request, is blocked, but is blocking others or session is idle but has an open tran and is blocking others
																							WHEN r2.session_id IS NOT NULL AND (r.blocking_session_id = 0 OR r.session_id IS NULL) THEN ''1''
																							-- session is either not blocking someone, or is blocking someone but is blocked by another party
																							ELSE ''''
																						END
														, Total_CPU_ms 				= s.cpu_time
														, Total_Physical_IO_in_MB	= (s.reads + s.writes) * 8 / 1024
														, Memory_USE_KB 			= s.memory_usage * 8192 / 1024
														, Open_Transactions 		= ISNULL(r.open_transaction_count,0)
														, Login_Time 				= s.login_time
														, Last_Request_Start_Time 	= s.last_request_start_time
														, Host_Name 				= ISNULL(s.host_name, N'''')
														, Net_Address				= ISNULL(c.client_net_address, N'''')
														, Execution_Context_ID 		= ISNULL(t.exec_context_id, 0)
														, Request_ID 				= ISNULL(r.request_id, 0)
													--   [Workload Group] 			= ISNULL(g.name, N'''')
													FROM sys.dm_exec_sessions s 
													LEFT OUTER JOIN sys.dm_exec_connections c 
														ON (s.session_id = c.session_id)
													LEFT OUTER JOIN sys.dm_exec_requests r 
														ON (s.session_id = r.session_id)
													LEFT OUTER JOIN sys.dm_os_tasks t 
														ON (r.session_id = t.session_id AND r.request_id = t.request_id)
													LEFT OUTER JOIN (
																		-- In some cases (e.g. parallel queries, also waiting for a worker), one thread can be flagged as
																		-- waiting for several different threads.  This will cause that thread to show up in multiple rows
																		-- in our grid, which we don''t want.  Use ROW_NUMBER to select the longest wait for each thread,
																		-- and use it as representative of the other wait relationships this thread is involved in.
																		SELECT *, ROW_NUMBER() OVER (PARTITION BY waiting_task_address ORDER BY wait_duration_ms DESC) AS row_num
																		FROM sys.dm_os_waiting_tasks
																	) AS w 
														ON (t.task_address = w.waiting_task_address) 
														AND w.row_num = 1
													LEFT OUTER JOIN sys.dm_exec_requests r2 
														ON (s.session_id = r2.blocking_session_id)
													--LEFT OUTER JOIN sys.dm_resource_governor_workload_groups g ON (g.group_id = s.group_id)	--TAKE THIS dmv OUT TO WORK IN 2005
													LEFT OUTER JOIN sys.sysprocesses p 
														ON (s.session_id = p.spid)
													ORDER BY s.session_id;
				
				'			
		SELECT @ERR = @@ERROR
		
		IF (@ERR <> 0) 
		BEGIN 
			PRINT 'msdb.dbo.sp_add_jobstep failed for Step 6: Activity Monitor'
			ROLLBACK TRANSACTION Add_AMS_PD_Job
			RETURN
		END
	End

		--
		--	Step 6: Table Stats - RowCounts,Heap,PKWithNoClustered,totalpages
		--
		If not exists(select * from msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_name =@StepName and database_name = @DBNAME)
     Begin	
		EXECUTE msdb.dbo.sp_add_jobstep
				  @job_id					=	@JobID
				, @step_id					=	6
				, @step_name				=	N'Table Stats - RowCounts,Heap,PKWithNoClustered,totalpages'
				, @subsystem				=	'TSQL'
				, @on_success_action		=	3
				, @on_success_step_id		=	0
				, @on_fail_action			=	3
				, @on_fail_step_id			=	0
				, @database_name			=	@DBNAME
				, @flags					=	6
				, @command					=	N'
													-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
													--
													--	Purpose	:	List Table Stats - RowCounts,Heap,PKWithNoClustered,totalpages
													--	Author	:	Faizan Khundmiri for AMS (NCR) on March 5, 2013
													--
													-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

													INSERT INTO DBA.PD_TableStats(Table_Name, Index_Name, Index_Type, RowCounts, TotalSpaceKB, Is_Primary_Key)
													SELECT    so.name																			AS [Table_Name]
															, si.name																			AS [Index_Name]
															, CASE	WHEN si.is_primary_key = 0 and si.type = 0 THEN ''HEAP''
																	WHEN si.is_primary_key = 1 and si.type = 2 THEN ''PrimaryKey_NonClustered''
																	WHEN si.is_primary_key = 0 and si.type = 2 THEN ''Non-Clustered''
																	ELSE ''Clustered''	
															  END																				AS	[Index_Type]
															, p.Rows																			AS	[RowCounts]
															, SUM(a.total_pages) * 8															AS	[TotalSpaceKB]
															, si.is_primary_key																	AS	[Is_Primary_Key]
													FROM sys.indexes si  
													INNER JOIN sys.objects so 
														ON	si.[object_id] = so.[object_id] 
													INNER JOIN sys.partitions AS p 
														ON	si.Object_id = p.object_id AND si.Index_id = p.index_id
													INNER JOIN sys.Allocation_units AS a
														ON   p.partition_id = a.container_id
													WHERE so.type = ''U''    --Only get indexes for User Created Tables 
													GROUP BY so.name , si.name , si.type_desc , p.Rows , si.is_primary_key , si.type
													ORDER BY so.name
												'

												
		SELECT @ERR = @@ERROR
		
		IF (@ERR <> 0) 
		BEGIN 
			PRINT 'msdb.dbo.sp_add_jobstep failed for Step 6: Table Stats - RowCounts,Heap,PKWithNoClustered,totalpages'
			ROLLBACK TRANSACTION Add_AMS_PD_Job
			RETURN
		END
	End	
		
		--
		--	Step 7: Check Last Update Statistics
		--
		If not exists(select * from msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_name =@StepName and database_name = @DBNAME)
      Begin
		EXECUTE msdb.dbo.sp_add_jobstep
				  @job_id					=	@JobID
				, @step_id					=	7
				, @step_name				=	N'Check Last Update Statistics'
				, @subsystem				=	'TSQL'
				, @on_success_action		=	3
				, @on_success_step_id		=	0
				, @on_fail_action			=	3
				, @on_fail_step_id			=	0
				, @database_name			=	@DBNAME
				, @flags					=	6
				, @command					=	N'
													-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
													--
													--	Purpose	:	List Last Update Statistics
													--	Author	:	Faizan Khundmiri for AMS (NCR) on March 5, 2013
													--
													-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

													INSERT INTO DBA.PD_UpdateStatistics(Table_Name, Statistic, [Statistic Type], [Stats Last Updated], ModifiedRows,No_Recompute)
													SELECT    sch.name + ''.'' + so.name													AS [Table_Name]
															, ss.name																		AS [Statistic]
															, CASE
																WHEN ss.auto_Created = 0 AND ss.user_created = 0 THEN ''Index Statistic'' 
																WHEN ss.auto_created = 0 AND ss.user_created = 1 THEN ''User Created'' 
																WHEN ss.auto_created = 1 AND ss.user_created = 0 THEN ''Auto Created'' 
																END																			AS [Statistic Type] 
															, STATS_DATE(i.[id], i.indid) 													AS [Stats Last Updated]
															, i.rowmodctr																	AS [ModifiedRows]
															, ss.No_Recompute																AS [No_Recompute]
													FROM sys.stats ss 
													JOIN sys.objects so 
														ON	ss.object_id = so.object_id
													JOIN sysindexes i
													     ON so.object_id = i.id
													JOIN sys.schemas sch
															ON   so.schema_id = sch.schema_id
													--OUTER APPLY sys.dm_db_stats_properties(so.object_id, ss.stats_id) AS sp										   
													WHERE so.TYPE = ''U''          
													ORDER BY STATS_DATE(i.[id], i.indid) DESC;
												'

												
		SELECT @ERR = @@ERROR
		
		IF (@ERR <> 0) 
		BEGIN 
			PRINT 'msdb.dbo.sp_add_jobstep failed for Step 7: Check Last Update Statistics'
			ROLLBACK TRANSACTION Add_AMS_PD_Job
			RETURN
		END
	End	
		
		--
		--	Step 8: Check Sql Hardware Information
		--
		If not exists(select * from msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_name =@StepName and database_name = @DBNAME)
     Begin
		EXECUTE msdb.dbo.sp_add_jobstep
				  @job_id					=	@JobID
				, @step_id					=	8
				, @step_name				=	N'Check Sql Hardware Information'
				, @subsystem				=	'TSQL'
				, @on_success_action		=	3
				, @on_success_step_id		=	0
				, @on_fail_action			=	3
				, @on_fail_step_id			=	0
				, @database_name			=	@DBNAME
				, @flags					=	6
				, @command					=	N'
													-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
													--
													--	Purpose	:	Gather Hardware information of the Sql Server machine
													--	Author	:	Uday K. Sangepu on March 6, 2013
													--
													-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

													WITH ServerHardware ([Sql and OS Version], [NoF Physical CPUs], [NoF Logical CPUs], [Physical Mem in GB], [Available Physical Mem in GB], [Total Page File Size in GB], [System Memory State], [Is it a VM], [SqlServer Instance Start Time]) AS 
													(
														--	Memory
														SELECT	  
																  NULL																	AS [Sql and OS Version]
																, NULL																	AS [NoF Physical CPUs]
																, NULL																	AS [NoF Logical CPUs]
																, CONVERT(NUMERIC(5,2), total_physical_memory_kb/(1024*1024.0))			AS [Physical Mem in GB]
																, CONVERT(NUMERIC(5,2), available_physical_memory_kb/(1024*1024.0))		AS [Available Physical Mem in GB]
																, CONVERT(NUMERIC(5,2), total_page_file_kb/(1024*1024.0))				AS [Total Page File Size in GB]
																, CONVERT(VARCHAR(20), system_memory_state_desc)						AS [System Memory State]
																, NULL																	AS [Is it a VM]
																, NULL																	AS [SqlServer Instance Start Time]
														FROM sys.dm_os_sys_memory
														UNION 
														--	CPU
														SELECT	  
																  CONVERT(VARCHAR(200), @@VERSION)										AS [Sql and OS Version]
																, cpu_count/hyperthread_ratio											AS [NoF Physical CPUs]
																, cpu_count																AS [NoF Logical CPUs]
																, NULL																	AS [Physical Mem in GB]
																, NULL																	AS [Available Physical Mem in GB]
																, NULL																	AS [Total Page File Size in GB]
																, NULL																	AS [System Memory State]
																, CONVERT(VARCHAR(10), virtual_machine_type_desc)						AS [Is it a VM]
																, sqlserver_start_time													AS [SqlServer Instance Start Time]
														FROM sys.dm_os_sys_info
													)
													--	SELECT * FROM ServerHardware
													INSERT INTO DBA.PD_ServerHardware (	[Sql and OS Version]
																					, [NoF Physical CPUs]
																					, [NoF Logical CPUs]
																					, [Physical Mem in GB]
																					, [Available Physical Mem in GB]
																					, [Total Page File Size in GB]
																					, [System Memory State]
																					, [Is it a VM]
																					, [SqlServer Instance Start Time]
																					)
													SELECT    MAX([Sql and OS Version])					AS [Sql and OS Version]
															, MAX([NoF Physical CPUs])					AS [NoF Physical CPUs]
															, MAX([NoF Logical CPUs])					AS [NoF Logical CPUs]
															, MAX([Physical Mem in GB])					AS [Physical Mem in GB]
															, MAX([Available Physical Mem in GB])		AS [Available Physical Mem in GB]
															, MAX([Total Page File Size in GB])			AS [Total Page File Size in GB]
															, MAX([System Memory State])				AS [System Memory State]
															, MAX([Is it a VM])							AS [Is it a VM]
															, MAX([SqlServer Instance Start Time])		AS [SqlServer Instance Start Time]
													FROM ServerHardware
												'

												
		SELECT @ERR = @@ERROR
		
		IF (@ERR <> 0) 
		BEGIN 
			PRINT 'msdb.dbo.sp_add_jobstep failed for Step 9: Check Sql Hardware Information'
			ROLLBACK TRANSACTION Add_AMS_PD_Job
			RETURN
		END
	End	
		
		--
		--	Step 9: Purge
		--
		If not exists(select * from msdb.dbo.sysjobsteps WHERE job_id = @jobId and step_name =@StepName and database_name = @DBNAME)
     Begin
		EXECUTE msdb.dbo.sp_add_jobstep
				  @job_id					=	@JobID
				, @step_id					=	9
				, @step_name				=	N'Purge'
				, @subsystem				=	'TSQL'
				, @on_success_action		=	1
				, @on_success_step_id		=	0
				, @on_fail_action			=	2
				, @on_fail_step_id			=	0
				, @database_name			=	@DBNAME
				, @flags					=	6
				, @command					=	N'
													-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
													--
													--	Purpose	:	Purge data collected above periodically			Retention										
													--			i)		DBA.PD_WaitStats							6 months
													--			ii)		DBA.PD_TopQueries							6 months
													--			iii)	DBA.PD_Missing_Indexes						6 months
													--			iv)		DBA.PD_Index_Usage							6 months
													--			v)		DBA.PD_FKs_With_NoIndexes					6 months
													--			vi)		DBA.PD_IndexPhysicalStats					6 months
													--			vii)	DBA.PD_ActivityMonitor						6 months
													--			viii)	DBA.PD_Duplicate_Indexes					6 months
													--          ix)     DBA.PD_TableStats 						    6 months
													--			x)      DBA.PD_UpdateStatistics 					6 months
													--			xi)     DBA.PD_ServerHardware						6 months
													--			xii)	DBA.PD_PerfCounters							6 months        
													--	Author	:	Uday K. Sangepu for AMS (NCR) on December 13, 2012
													--				On March 5th, 2013 Faizan Added DBA.PD_TableStats, DBA.PD_UpdateStatistics, DBA.PD_PerfCounters
													--				On March 6th 2013 Uday K. Sangepu added DBA.PD_ServerHardware
													-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

													--
													--	Purge data older than retention period (6 months)
													--
									
														
														DELETE FROM DBA.PD_WaitStats 			WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -1, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%5 = 0
														DELETE FROM DBA.PD_WaitStats 			WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%4 = 0
														DELETE FROM DBA.PD_WaitStats 			WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%3 = 0
														DELETE FROM DBA.PD_WaitStats 			WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -6, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%2 = 0
														DELETE FROM DBA.PD_WaitStats 			WHERE Created_On < DATEADD(MM, -7, GETDATE())

														DELETE FROM DBA.PD_TopQueries 			WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -1, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%5 = 0
														DELETE FROM DBA.PD_TopQueries 			WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%4 = 0
														DELETE FROM DBA.PD_TopQueries 			WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%3 = 0
														DELETE FROM DBA.PD_TopQueries 			WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -6, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%2 = 0
														DELETE FROM DBA.PD_TopQueries 			WHERE Created_On < DATEADD(MM, -7, GETDATE())

														DELETE FROM DBA.PD_Missing_Indexes 		WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -1, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%5 = 0
														DELETE FROM DBA.PD_Missing_Indexes 		WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%4 = 0
														DELETE FROM DBA.PD_Missing_Indexes 		WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%3 = 0
														DELETE FROM DBA.PD_Missing_Indexes 		WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -6, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%2 = 0
														DELETE FROM DBA.PD_Missing_Indexes 		WHERE Created_On < DATEADD(MM, -7, GETDATE())

														DELETE FROM DBA.PD_Index_Usage 			WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -1, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%5 = 0
														DELETE FROM DBA.PD_Index_Usage 			WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%4 = 0
														DELETE FROM DBA.PD_Index_Usage 			WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%3 = 0
														DELETE FROM DBA.PD_Index_Usage 			WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -6, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%2 = 0
														DELETE FROM DBA.PD_Index_Usage 			WHERE Created_On < DATEADD(MM, -7, GETDATE())

														DELETE FROM DBA.PD_FKs_With_NoIndexes 	WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -1, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%5 = 0
														DELETE FROM DBA.PD_FKs_With_NoIndexes 	WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%4 = 0
														DELETE FROM DBA.PD_FKs_With_NoIndexes 	WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%3 = 0
														DELETE FROM DBA.PD_FKs_With_NoIndexes 	WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -6, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%2 = 0
														DELETE FROM DBA.PD_FKs_With_NoIndexes 	WHERE Created_On < DATEADD(MM, -7, GETDATE())


														DELETE FROM DBA.PD_IndexPhysicalStats 	WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -1, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%5 = 0
														DELETE FROM DBA.PD_IndexPhysicalStats 	WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%4 = 0
														DELETE FROM DBA.PD_IndexPhysicalStats 	WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%3 = 0
														DELETE FROM DBA.PD_IndexPhysicalStats 	WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -6, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%2 = 0
														DELETE FROM DBA.PD_IndexPhysicalStats 	WHERE Created_On < DATEADD(MM, -7, GETDATE())

														DELETE FROM DBA.PD_ActivityMonitor 		WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -1, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%5 = 0
														DELETE FROM DBA.PD_ActivityMonitor 		WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%4 = 0
														DELETE FROM DBA.PD_ActivityMonitor 		WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%3 = 0
														DELETE FROM DBA.PD_ActivityMonitor 		WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -6, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%2 = 0
														DELETE FROM DBA.PD_ActivityMonitor 		WHERE Created_On < DATEADD(MM, -7, GETDATE())

														DELETE FROM DBA.PD_TableStats 			WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -1, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%5 = 0
														DELETE FROM DBA.PD_TableStats 			WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%4 = 0
														DELETE FROM DBA.PD_TableStats 			WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%3 = 0
														DELETE FROM DBA.PD_TableStats 			WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -6, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%2 = 0
														DELETE FROM DBA.PD_TableStats 			WHERE Created_On < DATEADD(MM, -7, GETDATE())
														
														DELETE FROM DBA.PD_UpdateStatistics 	WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -1, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%5 = 0
														DELETE FROM DBA.PD_UpdateStatistics 	WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%4 = 0
														DELETE FROM DBA.PD_UpdateStatistics 	WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%3 = 0
														DELETE FROM DBA.PD_UpdateStatistics 	WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -6, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%2 = 0
														DELETE FROM DBA.PD_UpdateStatistics 	WHERE Created_On < DATEADD(MM, -7, GETDATE())
														
														DELETE FROM DBA.PD_ServerHardware 		WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -1, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%5 = 0
														DELETE FROM DBA.PD_ServerHardware 		WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -2, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%4 = 0
														DELETE FROM DBA.PD_ServerHardware 		WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -3, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%3 = 0
														DELETE FROM DBA.PD_ServerHardware 		WHERE Created_On BETWEEN CONVERT(SMALLDATETIME, DATEADD(MM, -6, GETDATE())) AND CONVERT(SMALLDATETIME, DATEADD(MM, -4, GETDATE())) AND CONVERT(INT, DATEPART(D, Created_On))%2 = 0
														DELETE FROM DBA.PD_ServerHardware 		WHERE Created_On < DATEADD(MM, -7, GETDATE())

														'			
		SELECT @ERR = @@ERROR
		
		IF (@ERR <> 0) 
		BEGIN 
			PRINT 'msdb.dbo.sp_add_jobstep failed for Step 11: Purge'
			ROLLBACK TRANSACTION Add_AMS_PD_Job
			RETURN
		END
	End

		-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
		--	III)	Create Schedule
		-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
		
		DECLARE @ScheduleID	INT

		EXECUTE msdb.dbo.sp_add_schedule
				  @schedule_name			=	'Daily_At_10PM'
				, @enabled					=	1
				, @freq_type				=	4
				, @freq_interval			=	1
				, @freq_subday_type			=	0
				, @freq_subday_interval		=	0
				, @active_start_date		=	20130101
				, @active_end_date			=	99991231
				, @active_start_time		=	220000
				, @active_end_time			=	235959
				, @schedule_id				=	@ScheduleID OUTPUT

		SELECT @ERR = @@ERROR
		
		IF (@ERR <> 0) 
		BEGIN 
			PRINT 'msdb.dbo.sp_add_schedule failed for Daily_At_10PM'
			ROLLBACK TRANSACTION Add_AMS_PD_Job
			RETURN
		END
			
		SELECT @ScheduleID AS [Job Schedule]		
		
		-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
		--	IV)	Create Schedule
		-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
		
		EXECUTE msdb.dbo.sp_attach_schedule
				  @job_id					=	@JobID
				, @schedule_id				=	@ScheduleID

		SELECT @ERR = @@ERROR
		
		IF (@ERR <> 0) 
		BEGIN 
			PRINT 'msdb.dbo.sp_attach_schedule failed'
			ROLLBACK TRANSACTION Add_AMS_PD_Job
			RETURN
		END


		-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
		--	V)	Modify Job
		-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
		
		EXECUTE msdb.dbo.sp_update_job 
				  @job_id					=	@JobID
				, @start_step_id			=	1
		
		SELECT @ERR = @@ERROR

		IF (@ERR <> 0) 
		BEGIN 
			PRINT 'msdb.dbo.sp_update_job failed'
			ROLLBACK TRANSACTION Add_AMS_PD_Job
			RETURN
		END

		-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
		--	VI)	Add Job To Server
		-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
				
		EXECUTE msdb.dbo.sp_add_jobserver
				  @job_id					=	@JobID
				, @server_name				=	N'(LOCAL)'


		SELECT @ERR = @@ERROR

		IF (@ERR <> 0) 
		BEGIN 
			PRINT 'msdb.dbo.sp_add_jobserver failed'
			ROLLBACK TRANSACTION Add_AMS_PD_Job
			RETURN
		END
				
		COMMIT TRANSACTION Add_AMS_PD_Job	
END TRY

BEGIN CATCH
    DECLARE @ErrMsg NVARCHAR(max)
    DECLARE @ErrProc NVARCHAR(max)
    DECLARE @ErrLine INTEGER
	SELECT 
	        @ErrProc = ERROR_PROCEDURE(),
	        @ErrLine = ERROR_LINE(),
			@ErrMsg = ERROR_MESSAGE();

	--RAISERROR (N'%s(%d) %s', 18, 1, @ErrProc, @ErrLine, @ErrMsg)
	
	ROLLBACK TRANSACTION Add_AMS_PD_Job

END CATCH

GO

--
--	End of script:	PD_Job.sql
--



--
-- F:\ci-build\workspace\logix_7.3.1\Logix\tags\7.3.1/Source/sql_scripts/PrefManRT/tables/ --
--
print 'processing tables/Copient_Logix.User.sql'; 
--
GO
-- $Id: Copient_Logix.User.sql 31139 2011-05-16 18:03:10Z mark $
-- Build Version: 7.3.1.138972
/****** Object:  User [Copient_Logix]    Script Date: 12/27/2010 16:15:03 ******/
IF NOT EXISTS (SELECT * FROM sys.database_principals WHERE name = N'Copient_Logix')
CREATE USER [Copient_Logix] FOR LOGIN [Copient_Logix] WITH DEFAULT_SCHEMA=[dbo]
GO


print 'processing tables/Copient_Logix_uspRole.Schema.sql'; 
--
GO
-- $Id: Copient_Logix_uspRole.Schema.sql 35768 2011-08-17 20:56:23Z mark $
-- Build Version: 7.3.1.138972

/****** Object:  Schema [Copient_Logix_uspRole]    Script Date: 12/27/2010 15:04:02 ******/
-- This was accidentally made to create a schema instead of a role, so drop the schema if it exists and make the role
IF EXISTS (SELECT 1 FROM sys.schemas WHERE name = N'Copient_Logix_uspRole')
    DROP SCHEMA [Copient_Logix_uspRole] 
GO

IF NOT EXISTS ( SELECT 1 FROM [sys].[database_principals] where name = 'Copient_Logix_uspRole' and type = 'R'  )
  CREATE ROLE [Copient_Logix_uspRole] AUTHORIZATION [dbo]
GO

IF EXISTS (SELECT 1 FROM sys.database_principals WHERE name = N'Copient_Logix')
    exec sp_addrolemember 'Copient_Logix_uspRole', 'Copient_Logix'
GO



print 'processing tables/dbo.AMSPrefDistribution.Table.sql'; 
--
GO
-- $Id: dbo.AMSPrefDistribution.Table.sql 31141 2011-05-16 18:09:04Z mark $
-- Build Version: 7.3.1.138972

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO

-- 20100516.MM: Create table to store the last UpdateLevel of each preference record sent by each PromoEngine
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AMSPrefDistribution]') AND type in (N'U')) BEGIN
  CREATE TABLE [dbo].[AMSPrefDistribution](
    [PKID] [bigint] IDENTITY(1,1) NOT NULL,
    [PreferenceID] [bigint] NOT NULL,
    [PromoEngineID] [int] NOT NULL,
    [LastUpdateLevel] [int] NOT NULL,
    [LastSent] [datetime],
  CONSTRAINT [PK_AMSPrefDistribution] PRIMARY KEY CLUSTERED ([PKID] ASC) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
  ) ON [PRIMARY]
END
GO

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[AMSPrefDistribution]') AND name = N'IX_Unique_AMSPrefDistribution')
  CREATE UNIQUE NONCLUSTERED INDEX [IX_Unique_AMSPrefDistribution] ON [dbo].[AMSPrefDistribution] ([PreferenceID] ASC, [PromoEngineID] ASC)WITH (IGNORE_DUP_KEY = OFF) ON [PRIMARY]
GO




--
-- F:\ci-build\workspace\logix_7.3.1\Logix\tags\7.3.1/Source/sql_scripts/PrefManRT/views/ --
--

--
-- F:\ci-build\workspace\logix_7.3.1\Logix\tags\7.3.1/Source/sql_scripts/PrefManRT/functions/ --
--

--
-- F:\ci-build\workspace\logix_7.3.1\Logix\tags\7.3.1/Source/sql_scripts/PrefManRT/storedprocedures/ --
--
print 'processing storedprocedures/dbo.pmams_PrefsToSend_Active.StoredProcedure.sql'; 
--
GO
-- $Id: dbo.pmams_PrefsToSend_Active.StoredProcedure.sql 40687 2011-11-30 16:11:37Z mark $
-- Build Version: 7.3.1.138972

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- 20101012.AM: Create stored procedure to check if a user is permitted for activities associated with the specified permission ID. 
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[pmams_PrefsToSend_Active]') AND type in (N'P', N'PC'))
  DROP PROCEDURE [dbo].[pmams_PrefsToSend_Active]
GO
CREATE PROCEDURE [dbo].[pmams_PrefsToSend_Active] @PromoEngineID int
AS 
  SET NOCOUNT ON;
  
  select P.PreferenceID, P.UpdateLevel 
  from Preferences as P with (NoLock) Inner Join PreferenceChannels as PC with (NoLock) on P.PreferenceID=PC.PreferenceID and PC.ChannelID=1
  Left Join AMSPrefDistribution as APD with (NoLock) on P.PreferenceID=APD.PreferenceID  and APD.PromoEngineID=@PromoEngineID
  where P.Deleted=0 and (P.UpdateLevel>APD.LastUpdateLevel or APD.LastUpdateLevel is NULL)  

GO

GRANT EXECUTE ON [dbo].[pmams_PrefsToSend_Active] TO [Copient_Logix] AS [dbo]
GO



print 'processing storedprocedures/dbo.pmams_PrefsToSend_Deleted.StoredProcedure.sql'; 
--
GO
-- $Id: dbo.pmams_PrefsToSend_Deleted.StoredProcedure.sql 31218 2011-05-18 14:59:20Z mark $
-- Build Version: 7.3.1.138972

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- 20101012.AM: Create stored procedure to check if a user is permitted for activities associated with the specified permission ID. 
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[pmams_PrefsToSend_Deleted]') AND type in (N'P', N'PC'))
  DROP PROCEDURE [dbo].[pmams_PrefsToSend_Deleted]
GO
CREATE PROCEDURE [dbo].[pmams_PrefsToSend_Deleted] @PromoEngineID int
AS 
  SET NOCOUNT ON;
  
  -- returns a list of preferences where the UpdateLevel is higher than the corresponding level in AMSPrefDistribution
  -- and no longer exists in PreferenceChannels (has been disassociated with the channel) and the preference is marked as deleted
  select P.PreferenceID, P.UpdateLevel 
  from Preferences as P with (NoLock) Inner Join AMSPrefDistribution as APD with (NoLock) on P.PreferenceID=APD.PreferenceID
  where P.Deleted=1 and (APD.PromoEngineID=@PromoEngineID and P.UpdateLevel>APD.LastUpdateLevel)
  and not exists(select 1 from PreferenceChannels where PreferenceID=P.PreferenceID and ChannelID=1)

GO

GRANT EXECUTE ON [dbo].[pmams_PrefsToSend_Deleted] TO [Copient_Logix] AS [dbo]
GO



print 'processing storedprocedures/dbo.pmams_PrefsToSend_Disassociated.StoredProcedure.sql'; 
--
GO
-- $Id: dbo.pmams_PrefsToSend_Disassociated.StoredProcedure.sql 31219 2011-05-18 15:03:06Z mark $
-- Build Version: 7.3.1.138972

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- 20101012.AM: Create stored procedure to check if a user is permitted for activities associated with the specified permission ID. 
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[pmams_PrefsToSend_Disassociated]') AND type in (N'P', N'PC'))
  DROP PROCEDURE [dbo].[pmams_PrefsToSend_Disassociated]
GO
CREATE PROCEDURE [dbo].[pmams_PrefsToSend_Disassociated] @PromoEngineID int
AS 
  SET NOCOUNT ON;
  
  -- returns a list of preferences where the UpdateLevel is higher than the corresponding level in AMSPrefDistribution
  -- and no longer exists in PreferenceChannels (has been disassociated with the channel)
  select P.PreferenceID, P.UpdateLevel 
  from Preferences as P with (NoLock) Inner Join AMSPrefDistribution as APD with (NoLock) on P.PreferenceID=APD.PreferenceID
  where (APD.PromoEngineID=@PromoEngineID and P.UpdateLevel>APD.LastUpdateLevel)
  and not exists(select 1 from PreferenceChannels where PreferenceID=P.PreferenceID and ChannelID=1)

GO

GRANT EXECUTE ON [dbo].[pmams_PrefsToSend_Disassociated] TO [Copient_Logix] AS [dbo]
GO



print 'processing storedprocedures/dbo.pmams_Prefs_UpdateLastSent.StoredProcedure.sql'; 
--
GO
-- $Id: dbo.pmams_Prefs_UpdateLastSent.StoredProcedure.sql 31138 2011-05-16 18:00:22Z mark $
-- Build Version: 7.3.1.138972

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- 20101012.AM: Create stored procedure to check if a user is permitted for activities associated with the specified permission ID. 
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[pmams_Prefs_UpdateLastSent]') AND type in (N'P', N'PC'))
  DROP PROCEDURE [dbo].[pmams_Prefs_UpdateLastSent]
GO
CREATE PROCEDURE [dbo].[pmams_Prefs_UpdateLastSent] @PreferenceID [bigint], @PromoEngineID [int], @UpdateLevel [int]
AS 
  SET NOCOUNT ON;
  
  if not exists (select 1 from AMSPrefDistribution where PreferenceID=@PreferenceID and PromoEngineID=@PromoEngineID) begin
    Insert into AMSPrefDistribution (PreferenceID, PromoEngineID, LastUpdateLevel) values (@PreferenceID, @PromoEngineID, 0)
  end
  Update AMSPrefDistribution set LastUpdateLevel=@UpdateLevel, LastSent=getdate() where PreferenceID=@PreferenceID and PromoEngineID=@PromoEngineID;

GO

GRANT EXECUTE ON [dbo].[pmams_Prefs_UpdateLastSent] TO [Copient_Logix] AS [dbo]
GO




-- BEGIN SCRIPT FOOTER ------------------------------------------------------

-- Add/Update the DBVersion function
IF OBJECT_ID ( N'dbo.DBVersion', N'FN') IS NOT NULL
BEGIN
    DROP FUNCTION [dbo].[DBVersion]
END
GO

CREATE FUNCTION [dbo].[DBVersion]() RETURNS nvarchar(64) AS
BEGIN
    -- $Id: sqlcat_db2.pl 63227 2013-03-12 02:03:44Z jf185081 $
    -- Generated 2019-08-19 11:58:45
    -- Build Version: 7.3.1.138972
    return '7.3.1.138972';
END
GO

GRANT EXECUTE ON [dbo].[DBVersion] TO [Copient_Logix_uspRole] AS [dbo]
GO


-- Add/Update the DBGenerated function
IF OBJECT_ID ( N'dbo.DBGenerated', N'FN') IS NOT NULL
BEGIN
    DROP FUNCTION [dbo].[DBGenerated]
END
GO

CREATE FUNCTION [dbo].[DBGenerated]() RETURNS nvarchar(64) AS
BEGIN
    -- $Id: sqlcat_db2.pl 63227 2013-03-12 02:03:44Z jf185081 $
    -- Generated 2019-08-19 11:58:45
    -- Build Version: 7.3.1.138972
    return '2019-08-19 11:58:45';
END
GO

GRANT EXECUTE ON [dbo].[DBGenerated] TO [Copient_Logix_uspRole] AS [dbo]
GO





-- Add/Update the LogixDBName function
IF OBJECT_ID ( N'dbo.LogixDBName', N'FN') IS NOT NULL
BEGIN
    DROP FUNCTION [dbo].[LogixDBName]
END
GO

CREATE FUNCTION [dbo].[LogixDBName]() RETURNS nvarchar(64) AS
BEGIN
    -- $Id: sqlcat_db2.pl 63227 2013-03-12 02:03:44Z jf185081 $
    -- Generated 2019-08-19 11:58:45
    -- Build Version: 7.3.1.138972
    return 'PrefManRT';
END
GO

GRANT EXECUTE ON [dbo].[LogixDBName] TO [Copient_Logix_uspRole] AS [dbo]
GO


-- *********************************************
-- * GRANT EXECUTE USP and UDF SECTION         *
-- *********************************************
declare @CLRole as varchar(128)
set @CLRole = 'Copient_Logix_uspRole' --- Replace this with an appropriated role if different. Copient_Logix_uspRole is the recommended name for Logix.
IF EXISTS (select name from sys.database_principals where type='R' and name=@CLRole) BEGIN
  declare @uspudfName as varchar(128)
  declare uspCursor CURSOR FOR
    select name from sys.procedures where name not like 'sp[_]%'
    union select name from sys.objects where type='FN' and name not like 'fn_%'
    order by name FOR READ ONLY
  OPEN uspCursor
  FETCH uspCursor INTO @uspudfName
  WHILE @@FETCH_STATUS = 0 BEGIN
    EXECUTE('GRANT EXECUTE ON [' + @uspudfName + '] TO ' + @CLRole)
    FETCH uspCursor INTO @uspudfName
  END
  CLOSE uspCursor
  DEALLOCATE uspCursor
END
ELSE
    print 'Please create "@CLRole", or assign the right role in your system to @CLRole variable';
GO

print 'Completed PrefManRT'
print DB_NAME() + ' DBVersion is now ' + [dbo].[DBVersion]()
print CURRENT_TIMESTAMP;


